diff --git a/libc/Android.mk b/libc/Android.mk
index 9881d59..7dbdedd 100644
--- a/libc/Android.mk
+++ b/libc/Android.mk
@@ -319,6 +319,7 @@ libc_common_src_files := \
 	regex/regerror.c \
 	regex/regexec.c \
 	regex/regfree.c \
+	bionic/mntent_r.c \
 
 # The following files are common, but must be compiled
 # with different C flags when building a static C library.
diff --git a/libc/SYSCALLS.TXT b/libc/SYSCALLS.TXT
index c346d5a..0fceec7 100644
--- a/libc/SYSCALLS.TXT
+++ b/libc/SYSCALLS.TXT
@@ -54,6 +54,7 @@ ssize_t readahead(int, off64_t, size_t)     225
 int     getgroups:getgroups32(int, gid_t *)    205
 pid_t   getpgid(pid_t)             132
 pid_t   getppid()                  64
+pid_t   getsid(pid_t)              147
 pid_t   setsid()                   66
 int     setgid:setgid32(gid_t)     214
 int     seteuid:seteuid32(uid_t)   stub
diff --git a/libc/arch-arm/syscalls.mk b/libc/arch-arm/syscalls.mk
index 3fce36d..a4f5b30 100644
--- a/libc/arch-arm/syscalls.mk
+++ b/libc/arch-arm/syscalls.mk
@@ -18,6 +18,7 @@ syscall_src += arch-arm/syscalls/readahead.S
 syscall_src += arch-arm/syscalls/getgroups.S
 syscall_src += arch-arm/syscalls/getpgid.S
 syscall_src += arch-arm/syscalls/getppid.S
+syscall_src += arch-arm/syscalls/getsid.S
 syscall_src += arch-arm/syscalls/setsid.S
 syscall_src += arch-arm/syscalls/setgid.S
 syscall_src += arch-arm/syscalls/__setreuid.S
diff --git a/libc/arch-arm/syscalls/getsid.S b/libc/arch-arm/syscalls/getsid.S
new file mode 100644
index 0000000..856d41a
--- /dev/null
+++ b/libc/arch-arm/syscalls/getsid.S
@@ -0,0 +1,14 @@
+/* autogenerated by gensyscalls.py */
+#include <machine/asm.h>
+#include <sys/linux-syscalls.h>
+
+ENTRY(getsid)
+    .save   {r4, r7}
+    stmfd   sp!, {r4, r7}
+    ldr     r7, =__NR_getsid
+    swi     #0
+    ldmfd   sp!, {r4, r7}
+    movs    r0, r0
+    bxpl    lr
+    b       __set_syscall_errno
+END(getsid)
diff --git a/libc/arch-x86/syscalls.mk b/libc/arch-x86/syscalls.mk
index 2f8cc49..a714f0c 100644
--- a/libc/arch-x86/syscalls.mk
+++ b/libc/arch-x86/syscalls.mk
@@ -19,6 +19,7 @@ syscall_src += arch-x86/syscalls/readahead.S
 syscall_src += arch-x86/syscalls/getgroups.S
 syscall_src += arch-x86/syscalls/getpgid.S
 syscall_src += arch-x86/syscalls/getppid.S
+syscall_src += arch-x86/syscalls/getsid.S
 syscall_src += arch-x86/syscalls/setsid.S
 syscall_src += arch-x86/syscalls/setgid.S
 syscall_src += arch-x86/syscalls/__setreuid.S
diff --git a/libc/arch-x86/syscalls/getsid.S b/libc/arch-x86/syscalls/getsid.S
new file mode 100644
index 0000000..7046b9a
--- /dev/null
+++ b/libc/arch-x86/syscalls/getsid.S
@@ -0,0 +1,23 @@
+/* autogenerated by gensyscalls.py */
+#include <sys/linux-syscalls.h>
+
+    .text
+    .type getsid, @function
+    .globl getsid
+    .align 4
+
+getsid:
+    pushl   %ebx
+    mov     8(%esp), %ebx
+    movl    $__NR_getsid, %eax
+    int     $0x80
+    cmpl    $-129, %eax
+    jb      1f
+    negl    %eax
+    pushl   %eax
+    call    __set_errno
+    addl    $4, %esp
+    orl     $-1, %eax
+1:
+    popl    %ebx
+    ret
diff --git a/libc/bionic/mntent_r.c b/libc/bionic/mntent_r.c
new file mode 100644
index 0000000..2a58d2b
--- /dev/null
+++ b/libc/bionic/mntent_r.c
@@ -0,0 +1,281 @@
+/* Utilities for reading/writing fstab, mtab, etc.
+   Copyright (C) 1995-2000, 2001, 2002, 2003, 2006, 2010, 2011
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <alloca.h>
+#include <mntent.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/types.h>
+
+
+/* Prepare to begin reading and/or writing mount table entries from the
+   beginning of FILE.  MODE is as for `fopen'.  */
+FILE *setmntent (const char *file, const char *mode)
+{
+  /* Extend the mode parameter with "c" to disable cancellation in the
+     I/O functions and "e" to set FD_CLOEXEC.  */
+  size_t modelen = strlen (mode);
+  char newmode[modelen + 3];
+  memcpy (newmode, mode, modelen);
+  memcpy (newmode + modelen, "ce", 3);
+  FILE *result = fopen (file, newmode);
+
+  return result;
+}
+
+
+/* Close a stream opened with `setmntent'.  */
+int endmntent (FILE *stream)
+{
+  if (stream)		/* SunOS 4.x allows for NULL stream */
+    fclose (stream);
+  return 1;		/* SunOS 4.x says to always return 1 */
+}
+
+
+/* Since the values in a line are separated by spaces, a name cannot
+   contain a space.  Therefore some programs encode spaces in names
+   by the strings "\040".  We undo the encoding when reading an entry.
+   The decoding happens in place.  */
+static char *
+decode_name (char *buf)
+{
+  char *rp = buf;
+  char *wp = buf;
+
+  do
+    if (rp[0] == '\\' && rp[1] == '0' && rp[2] == '4' && rp[3] == '0')
+      {
+	/* \040 is a SPACE.  */
+	*wp++ = ' ';
+	rp += 3;
+      }
+    else if (rp[0] == '\\' && rp[1] == '0' && rp[2] == '1' && rp[3] == '1')
+      {
+	/* \011 is a TAB.  */
+	*wp++ = '\t';
+	rp += 3;
+      }
+    else if (rp[0] == '\\' && rp[1] == '0' && rp[2] == '1' && rp[3] == '2')
+      {
+	/* \012 is a NEWLINE.  */
+	*wp++ = '\n';
+	rp += 3;
+      }
+    else if (rp[0] == '\\' && rp[1] == '\\')
+      {
+	/* We have to escape \\ to be able to represent all characters.  */
+	*wp++ = '\\';
+	rp += 1;
+      }
+    else if (rp[0] == '\\' && rp[1] == '1' && rp[2] == '3' && rp[3] == '4')
+      {
+	/* \134 is also \\.  */
+	*wp++ = '\\';
+	rp += 3;
+      }
+    else
+      *wp++ = *rp;
+  while (*rp++ != '\0');
+
+  return buf;
+}
+
+
+/* Read one mount table entry from STREAM.  Returns a pointer to storage
+   reused on the next call, or null for EOF or error (use feof/ferror to
+   check).  */
+struct mntent *getmntent_r (FILE *stream, struct mntent *mp, char *buffer, int bufsiz)
+{
+  char *cp;
+  char *head;
+
+  do
+    {
+      char *end_ptr;
+
+      if (fgets (buffer, bufsiz, stream) == NULL)
+	{
+	  return NULL;
+	}
+
+      end_ptr = strchr (buffer, '\n');
+      if (end_ptr != NULL)	/* chop newline */
+	*end_ptr = '\0';
+      else
+	{
+	  /* Not the whole line was read.  Do it now but forget it.  */
+	  char tmp[1024];
+	  while (fgets (tmp, sizeof tmp, stream) != NULL)
+	    if (strchr (tmp, '\n') != NULL)
+	      break;
+	}
+
+      head = buffer + strspn (buffer, " \t");
+      /* skip empty lines and comment lines:  */
+    }
+  while (head[0] == '\0' || head[0] == '#');
+
+  cp = strsep (&head, " \t");
+  mp->mnt_fsname = cp != NULL ? decode_name (cp) : (char *) "";
+  if (head)
+    head += strspn (head, " \t");
+  cp = strsep (&head, " \t");
+  mp->mnt_dir = cp != NULL ? decode_name (cp) : (char *) "";
+  if (head)
+    head += strspn (head, " \t");
+  cp = strsep (&head, " \t");
+  mp->mnt_type = cp != NULL ? decode_name (cp) : (char *) "";
+  if (head)
+    head += strspn (head, " \t");
+  cp = strsep (&head, " \t");
+  mp->mnt_opts = cp != NULL ? decode_name (cp) : (char *) "";
+  switch (head ? sscanf (head, " %d %d ", &mp->mnt_freq, &mp->mnt_passno) : 0)
+    {
+    case 0:
+      mp->mnt_freq = 0;
+    case 1:
+      mp->mnt_passno = 0;
+    case 2:
+      break;
+    }
+
+  return mp;
+}
+
+struct mntent *getmntent (FILE *stream)
+{
+  static struct mntent m;
+  static char *getmntent_buffer;
+
+  #define BUFFER_SIZE 4096
+  if (getmntent_buffer == NULL) {
+    getmntent_buffer = (char *) malloc (BUFFER_SIZE);
+  }
+
+  return getmntent_r (stream, &m, getmntent_buffer, BUFFER_SIZE);
+  #undef BUFFER_SIZE
+}
+
+
+/* We have to use an encoding for names if they contain spaces or tabs.
+   To be able to represent all characters we also have to escape the
+   backslash itself.  This "function" must be a macro since we use
+   `alloca'.  */
+#define encode_name(name) \
+  do {									      \
+    const char *rp = name;						      \
+									      \
+    while (*rp != '\0')							      \
+      if (*rp == ' ' || *rp == '\t' || *rp == '\n' || *rp == '\\')	      \
+	break;								      \
+      else								      \
+	++rp;								      \
+									      \
+    if (*rp != '\0')							      \
+      {									      \
+	/* In the worst case the length of the string can increase to	      \
+	   four times the current length.  */				      \
+	char *wp;							      \
+									      \
+	rp = name;							      \
+	name = wp = (char *) alloca (strlen (name) * 4 + 1);		      \
+									      \
+	do								      \
+	  if (*rp == ' ')						      \
+	    {								      \
+	      *wp++ = '\\';						      \
+	      *wp++ = '0';						      \
+	      *wp++ = '4';						      \
+	      *wp++ = '0';						      \
+	    }								      \
+	  else if (*rp == '\t')						      \
+	    {								      \
+	      *wp++ = '\\';						      \
+	      *wp++ = '0';						      \
+	      *wp++ = '1';						      \
+	      *wp++ = '1';						      \
+	    }								      \
+	  else if (*rp == '\n')						      \
+	    {								      \
+	      *wp++ = '\\';						      \
+	      *wp++ = '0';						      \
+	      *wp++ = '1';						      \
+	      *wp++ = '2';						      \
+	    }								      \
+	  else if (*rp == '\\')						      \
+	    {								      \
+	      *wp++ = '\\';						      \
+	      *wp++ = '\\';						      \
+	    }								      \
+	  else								      \
+	    *wp++ = *rp;						      \
+	while (*rp++ != '\0');						      \
+      }									      \
+  } while (0)
+
+
+/* Write the mount table entry described by MNT to STREAM.
+   Return zero on success, nonzero on failure.  */
+int addmntent (FILE *stream, const struct mntent *mnt)
+{
+  struct mntent mntcopy = *mnt;
+  if (fseek (stream, 0, SEEK_END))
+    return 1;
+
+  /* Encode spaces and tabs in the names.  */
+  encode_name (mntcopy.mnt_fsname);
+  encode_name (mntcopy.mnt_dir);
+  encode_name (mntcopy.mnt_type);
+  encode_name (mntcopy.mnt_opts);
+
+  return (fprintf (stream, "%s %s %s %s %d %d\n",
+		   mntcopy.mnt_fsname,
+		   mntcopy.mnt_dir,
+		   mntcopy.mnt_type,
+		   mntcopy.mnt_opts,
+		   mntcopy.mnt_freq,
+		   mntcopy.mnt_passno) < 0
+	  || fflush (stream) != 0);
+}
+
+
+/* Search MNT->mnt_opts for an option matching OPT.
+   Returns the address of the substring, or null if none found.  */
+char *hasmntopt (const struct mntent *mnt, const char *opt)
+{
+  const size_t optlen = strlen (opt);
+  char *rest = mnt->mnt_opts, *p;
+
+  while ((p = strstr (rest, opt)) != NULL)
+    {
+      if ((p == rest || p[-1] == ',')
+	  && (p[optlen] == '\0' || p[optlen] == '=' || p[optlen] == ','))
+	return p;
+
+      rest = strchr (p, ',');
+      if (rest == NULL)
+	break;
+      ++rest;
+    }
+
+  return NULL;
+}
+
+
diff --git a/libc/bionic/stubs.c b/libc/bionic/stubs.c
index 5f63427..e909e05 100644
--- a/libc/bionic/stubs.c
+++ b/libc/bionic/stubs.c
@@ -30,7 +30,6 @@
 #include <unistd.h>
 #include <pwd.h>
 #include <netdb.h>
-#include <mntent.h>
 #include <private/android_filesystem_config.h>
 #include <pthread.h>
 #include <stdlib.h>
@@ -421,12 +420,6 @@ void endpwent(void)
 {
 }
 
-struct mntent* getmntent(FILE* f)
-{
-    fprintf(stderr, "FIX ME! implement getmntent() %s:%d\n", __FILE__, __LINE__);
-    return NULL;
-}
-
 char* ttyname(int fd)
 {
     fprintf(stderr, "FIX ME! implement ttyname() %s:%d\n", __FILE__, __LINE__);
diff --git a/libc/include/resolv.h b/libc/include/resolv.h
index bb21c23..0773849 100644
--- a/libc/include/resolv.h
+++ b/libc/include/resolv.h
@@ -60,7 +60,7 @@ extern void _resolv_set_nameservers_for_iface(const char* ifname, char** servers
 extern void _resolv_set_addr_of_iface(const char* ifname, struct in_addr* addr);
 
 /* flush the cache associated with the default interface */
-extern void _resolv_flush_cache_for_default_iface();
+extern void _resolv_flush_cache_for_default_iface(void);
 
 /* flush the cache associated with a certain interface */
 extern void _resolv_flush_cache_for_iface(const char* ifname);
diff --git a/libc/include/sys/linux-syscalls.h b/libc/include/sys/linux-syscalls.h
index 49fdf99..1aa7c7e 100644
--- a/libc/include/sys/linux-syscalls.h
+++ b/libc/include/sys/linux-syscalls.h
@@ -24,6 +24,7 @@
 #define __NR_getgroups32                  (__NR_SYSCALL_BASE + 205)
 #define __NR_getpgid                      (__NR_SYSCALL_BASE + 132)
 #define __NR_getppid                      (__NR_SYSCALL_BASE + 64)
+#define __NR_getsid                       (__NR_SYSCALL_BASE + 147)
 #define __NR_setsid                       (__NR_SYSCALL_BASE + 66)
 #define __NR_setgid32                     (__NR_SYSCALL_BASE + 214)
 #define __NR_setreuid32                   (__NR_SYSCALL_BASE + 203)
diff --git a/libc/include/sys/linux-unistd.h b/libc/include/sys/linux-unistd.h
index 693302d..a07cb25 100644
--- a/libc/include/sys/linux-unistd.h
+++ b/libc/include/sys/linux-unistd.h
@@ -24,6 +24,7 @@ ssize_t          readahead (int, off64_t, size_t);
 int              getgroups (int, gid_t *);
 pid_t            getpgid (pid_t);
 pid_t            getppid (void);
+pid_t            getsid (pid_t);
 pid_t            setsid (void);
 int              setgid (gid_t);
 int              seteuid (uid_t);
@@ -189,7 +190,6 @@ int              setsockopt (int, int, int, const void *, socklen_t);
 int              getsockopt (int, int, int, void *, socklen_t *);
 int              sendmsg (int, const struct msghdr *, unsigned int);
 int              recvmsg (int, struct msghdr *, unsigned int);
-int              __socketcall (int, unsigned long*);
 int              sched_setscheduler (pid_t pid, int policy, const struct sched_param *param);
 int              sched_getscheduler (pid_t pid);
 int              sched_yield (void);
